//ASYNC FILE SYSTEM
readFile or writeFile both take the address of the file you want to read or new address you want to write in.
they both take "utf8"( This is the meaning of “UTF”, or “Unicode Transformation Format.”) as their second argument.
and lastly a callback function with two parameters (err, result)

//SYNC FILE SYSTEM
readFileSync or writeFileSync both take the address of the file you want to read or new address you want to write in.
they both take "utf8"( This is the meaning of “UTF”, or “Unicode Transformation Format.”) as their second argument.
writeFileSync can also take {flag: 'a'} as the third parameter to concatinate.

//http request 
after require.
we can create server using http.createServer which takes a call back funtion that has two parameters req and res.
adding '.listen(5000)' will give where the server should run locally.
res.write('sdfew') can be use to pring on the browser which usually comes with res.end()


// PACKAGE.JSON 
package.json help stores information about the project(i.e you see numbers of dependencies you have)

//PACKAGE-LOCK.JSON 
There we have all the versions for the dependencies and other packages.

// Installing globally 
npm install -g <package-name>

//EVENT LOOP

(function() {

  console.log('this is the start');

  setTimeout(function cb() {
    console.log('Callback 1: this is a msg from call back');
  }); // has a default time value of 0

  console.log('this is just a message');

  setTimeout(function cb1() {
    console.log('Callback 2: this is a msg from call back');
  }, 0);

  console.log('this is the end');

})();

// "this is the start"
// "this is just a message"
// "this is the end"
// "Callback 1: this is a msg from call back"
// "Callback 2: this is a msg from call back"


The Node.js JavaScript code runs on a single thread. There is just one thing happening at a time.
You mainly need to be concerned that your code will run on a single event loop, 
and write code with this thing in mind to avoid blocking it.



//Blocking the event loop
Any JavaScript code that takes too long to return back control to 
the event loop will block the execution of any JavaScript code in
 the page, even block the UI thread, and the user cannot click around, 
 scroll the page, and so on.

Almost all the I/O primitives in JavaScript are non-blocking. 
Network requests, filesystem operations, and so on. Being blocking is the exception, 
and this is why JavaScript is based so much on callbacks, and more recently on promises 
and async/await.


//Example
const foo = () => {
  console.log('foo')
  setTimeout(bar, 0)
  new Promise((resolve, reject) =>
    resolve('should be right after baz, before bar')
  ).then(resolve => console.log(resolve))
  baz()
}

foo()

//Output
foo
baz
should be right after baz, before bar.
bar
//HOW IT ACTUALLY WORKS
foo() IN
console.log('foo') IN
console.log('foo') OUT
setTimeout() IN
setTimeout() OUT
new Promise((resolve, reject) =>) IN
resolve('should be right after baz, before bar') IN
resolve('should be right after baz, before bar') OUT
new Promise((resolve, reject) =>) OUT
baz() IN
console.log('baz') IN
console.log('baz') OUT
baz() OUT
resolve => console.log(resolve) IN
console.log('should be right after baz, before bar') IN
console.log('should be right after baz, before bar') OUT
resolve => console.log(resolve) OUT
bar() IN
console.log('bar') IN
console.log('bar') OUT
bar() OUT
foo() OUT
empty


//PROMISE
Note that () => x is short for () => { return x; }.

//EXAMPLE OF SYNC AND ASYNC SYNTAX
try {
  const result = syncDoSomething();
  const newResult = syncDoSomethingElse(result);
  const finalResult = syncDoThirdThing(newResult);
  console.log(`Got the final result: ${finalResult}`);
} catch(error) {
  failureCallback(error);
}

//ASYNC OF IT

async function foo() {
  try {
    const result = await doSomething();
    const newResult = await doSomethingElse(result);
    const finalResult = await doThirdThing(newResult);
    console.log(`Got the final result: ${finalResult}`);
  } catch(error) {
    failureCallback(error);
  }
}


Using async/await addresses most, 
if not all of these problems—the tradeoff being that the most
 common mistake with that syntax is forgetting the await keyword.














